[["introdution.html", "Mapping single-cell RNA-sequencing data on tissue using computations Introdution Sources of inspiration Bibliography", " Mapping single-cell RNA-sequencing data on tissue using computations Lorette Noiret, Nathalie Lehmann, Eric van Leen 2021-02-07 Introdution Objectives : Yesterday, we saw how to pre-process single cell rna seq (Chromium) to extract “high quality cells”. Today we will explore further a similar dataset and use a computional approach called novoSparc to reconstruct the spatial transcriptome. Before performing an advanced technic such as spatial transcriptomics, it is good to have some kind of validation. So as the first step, we will visualize co-expressed genes in UMAP and see if we can find the same co-expression in our predicted spatial transcriptome. In this pratical session, you will learn : how to visualize co-expressed genes in UMAP ; how to map dissociated single cells back to their tissue of origin using novoSpaRc (de novo Spatial Reconstruction of Single-Cell Gene Expression). We will be using one of the dataset publilshied with Nitizan et al. The data are alreay filtered (“high quality cells”) and log-normalized. Sources of inspiration This course material is based on Novosparc tutorial on github: novosparc tutorial: reconstruct_drosophila_embryo_tutorial.ipynb Bibliography {#Karaiskos2017} et al.The Drosophila embryo at single-cell transcriptome resolution. Science13 Oct 2017 : 194-199 {#Nitzan2019} et al. Gene expression cartography. Nature.2019 Dec;576(7785):132-137. working with Python in R "],["working-in-python-in-rstudio.html", " 1 Working in Python in RStudio", " 1 Working in Python in RStudio RStudio makes it easy to combine R and Python in a single data science project thanks to the package “reticulate”. You just need to specify the language you want to use at the beginning of the chunk. library(reticulate) # to use Python through a R framework # optional : check the version of Python that you are using (not useful for this workshop) # use_python(&quot;/usr/local/bin/python3.6&quot;, required = TRUE) To import package from Python, the syntax is a but different: import numpy as np # we use the alias np to call function from the package numpy import novosparc import matplotlib.pyplot as plt import anndata as an Create a variable x in Python : x = np.array([1,2,3]) print(x) Use the variable x in R by adding py$ in front of the variable name py$x ## NULL You can also create a new variable y in the Python session using R, and pass a data frame to y: py$y &lt;- head(cars) # cars is a dataset which is pre-installed in R Print the variable y in Python: print(y) "],["basic-vizualization.html", " 2 Basic vizualization 2.1 Import data in Seurat 2.2 A quick reminder on SeuratObject 2.3 Perform dimension reductions", " 2 Basic vizualization In this section, we will perfome some basic analyses of the dataset provided in Nitizan et al. using Seurat. We will group cells in clusters and visualise the group using UMAP. A quick analysis of the cluster to identfy Project Check if clusters of cells found in step 1 TO COMPLETE If you are not familiar with Seurat object and scRNAseq pre-processing, you can look at yesterday’s tutorial, which is available on github. 2.1 Import data in Seurat library(Seurat) We import the log-normalized high quality cells as a dataframe and then convert the dataframe to a Seurat object. log.nrmlz.matrix &lt;- read.table(&quot;data/data_day2/drosophila_scRNAseq/dge_normalized.txt&quot;, sep=&#39;\\t&#39;, row.names=1) dim(log.nrmlz.matrix) ## [1] 1963 1297 print(log.nrmlz.matrix[1:3,1:4]) ## GTACTAATTACN_2 AGGCTAATGGAC_3 TAGACAAAAGCT_4 TCTACTAGTGTN_5 ## 128up 2.570 2.509 0.000 0.000 ## 140up 1.160 3.007 0.000 0.000 ## 14-3-3epsilon 8.838 8.788 8.843 8.869 We have 1963 genes and 1297 cells dataset &lt;- CreateSeuratObject(counts = log.nrmlz.matrix) 2.2 A quick reminder on SeuratObject In Seurat, data are organised in different compartements (slots), which contains them-selves several compartements, which can them-selves contain sub compartments… slotNames(dataset) ## [1] &quot;assays&quot; &quot;meta.data&quot; &quot;active.assay&quot; &quot;active.ident&quot; &quot;graphs&quot; ## [6] &quot;neighbors&quot; &quot;reductions&quot; &quot;images&quot; &quot;project.name&quot; &quot;misc&quot; ## [11] &quot;version&quot; &quot;commands&quot; &quot;tools&quot; Each compartment can be used to store: data from multiple modalities, such as RNAseq (slot assays, sub-slot RNA), ATAC-seq… results of analyses: dimension reduction, clustering … *… You navigate through this hierarchy using @ and $ signs. slotNames(dataset@assays$RNA) ## [1] &quot;counts&quot; &quot;data&quot; &quot;scale.data&quot; &quot;key&quot; ## [5] &quot;assay.orig&quot; &quot;var.features&quot; &quot;meta.features&quot; &quot;misc&quot; The structure of the Seurat object reflects the pre-processing steps. The scRNAseq workflow consists of 3 main steps : * start with raw expression matrix (UMIs after sequencing) and filter out “low quality cells” : data are stored in the compartement counts; * log-normalize the data: to correct for sequencing biais : data * perform a dimension reduction such as PCA to reduce the computation time and unnecessary information. PCA requires the data to normalized and scaled : scale.data. 2.3 Perform dimension reductions When analysing scRNAseq data, you will usually perform some clustering to identify sub-populations and use some technique for visualization (e.g. UMAP). These analyses are performed on a lower dimensional space. Here we perform a PCA on the list of highly variable genes provided by the authors. list_hvg = read.csv(&quot;data/data_day2/drosophila_scRNAseq/high_var_genes.txt&quot;, header=FALSE) # the list of gene was imported as a dataframe, we can convert it to a list dataset@assays$RNA@var.features = as.list(list_hvg$V1) dataset &lt;- ScaleData(dataset) dataset &lt;- RunPCA(dataset, features = list_hvg$V1) DimPlot(dataset, reduction = &quot;pca&quot;) sum(dataset@reductions$pca@stdev[1:35]) ## [1] 49.57188 nPC = 35 # number of PC kept for the analysis n.neighbours = 15 resol = 0.4 # impact the number of clusters # k-nn graoh dataset &lt;- FindNeighbors(dataset, k.param = n.neighbours,dims = 1:nPC) ## Computing nearest neighbor graph ## Computing SNN # make the clusters dataset &lt;- FindClusters(dataset, resolution = resol) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 1297 ## Number of edges: 52276 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8298 ## Number of communities: 6 ## Elapsed time: 0 seconds dataset &lt;- RunUMAP(dataset, dims = 1:nPC) ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## 00:17:36 UMAP embedding parameters a = 0.9922 b = 1.112 ## 00:17:36 Read 1297 rows and found 35 numeric columns ## 00:17:36 Using Annoy for neighbor search, n_neighbors = 30 ## 00:17:36 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 00:17:36 Writing NN index file to temp file /tmp/RtmpXI7aEp/file1c341a6f166273 ## 00:17:36 Searching Annoy index using 1 thread, search_k = 3000 ## 00:17:36 Annoy recall = 100% ## 00:17:37 Commencing smooth kNN distance calibration using 1 thread ## 00:17:37 Initializing from normalized Laplacian + noise ## 00:17:38 Commencing optimization for 500 epochs, with 50690 positive edges ## 00:17:41 Optimization finished DimPlot(dataset, reduction = &quot;umap&quot;) # Select other genes #FeaturePlot(object = dataset, # features = c(&#39;ftz&#39;,&#39;ImpE2&#39;,&#39;sim&#39;), # cols = c(&quot;grey&quot;, &quot;blue&quot;), # reduction = &quot;umap&quot;) FeaturePlot(object = dataset, features = c(&#39;twi&#39;,&#39;zen&#39;,&#39;aay&#39;), cols = c(&quot;grey&quot;, &quot;blue&quot;), reduction = &quot;umap&quot;, pt.size = 0.2) "],["spatial-transcriptome-with-novosparc.html", " 3 Spatial transcriptome with novoSparc 3.1 Import data 3.2 Create the geometry of your tissue (target space)", " 3 Spatial transcriptome with novoSparc 3.1 Import data novoSpaRc is an algorithm that predicts the location of dissociated single cells. To work, the algorithm needs : the expression matrix of the single cells data the shape/geometry of the tissue of origin The performance is greatly increased if you provide some marker genes (also called landmarks / atlas) for which the expression patterns are known. 3.1.1 Single cells expression matrix # Single data : expression matrix (already imported) datafile_sc =&#39;data/data_day2/drosophila_scRNAseq/dge_normalized.txt&#39; # Optional : provide a list of highly variable genes (speed up the calculations if we only map a small number of genes) datafile_sc_hvg =&#39;data/data_day2/drosophila_scRNAseq/high_var_genes.txt&#39; # Optional : geometry of the tissue datafile_geom =&#39;data/data_day2/bdtnp/geometry.txt&#39; # Optional : Landamark genes = genes with known pattern of expression (eg. FISH image...) datafile_atlas =&#39;data/data_day2/bdtnp/atlas.txt&#39; How to format the single cell matrix : Novosparc expect a matrix with genes in columns and cells in rows. Be careful, this is not the usual order ! {#Nitizan} and al. advised to use the normalized gene expression matrix (e.g. using the global scaling log-normalization method) The data need to be in the Anndata format. Novosparc has a function to import an expression matrix and to convert it in theAnndataformat (alternativaly you can convert a pandas dataframe to anAnndata` easily). import novosparc dataset = novosparc.io.load_data(datafile_sc) dataset = dataset.T # in this example we have to tanspose the matrix to have gene in columns and cells in rows print (&#39;number of cells: &#39;,dataset.shape[0],&#39;\\nnumber of genes: &#39;, dataset.shape[1]) print(&quot;Gene names :&quot;, dataset.var.index.tolist()[:10]) # Alternative : convert a pandas dataframe to AnnData format # data = pd.read_csv(data_path,sep=&#39;\\t&#39;) # dataset = sc.AnnData(data ) # dataset = dataset2.T To save computation time, we will only map a subset of the genes. Here we will focus on a list of highly variable genes provided with the publication. hvg = np.genfromtxt(datafile_sc_hvg, dtype=&#39;str&#39;) dataset,hvg = novosparc.pp.subset_to_hvg(dataset, gene_list = hvg ) dataset.shape 3.2 Create the geometry of your tissue (target space) You need to create the grid that describes the shape of your tissue (location of the cells in the tissue). You have 3 options : either 1) you know the cellular locations and have them in a file ; either 2) you don’t know the cellular locations, but you know the shape of your tissue; either 3) you know nothing and will just assume that your tissue is a rectangle. 3.2.1 case 1 : you know the cellular locations We suppose that you have a file that contain the XYZ location of each cells in your tissue. Note : if your tissue is flat, you can set the Z-coordinate to 1. # Read and use the bdtnp geometry #locations = np.loadtxt(datafile_geom, usecols=range(3), skiprows=1) locations = novosparc.io.load_target_space(datafile_geom, is_2D=True) locations = locations[:3039, :] # we are just focusing on the first 3039 positions print(&quot;Number of location in the tissue &quot;,locations.shape[0]) print(locations[0:5,:]) Each line in the geometry file gives you the XYZ coordinate of a cell. plt.figure() plt.scatter(locations[:, 0], locations[:, 1], s=1) plt.show() plt.close() We can visualize all the position for which \\(Z=1\\) plt.figure() plt.scatter(locations[:, 0], locations[:, 1], s=1) plt.show() plt.close() 3.2.2 Alternative tissue spaces If you do not know the cellular locations of your tissue, you can create them. novoSpaRc has two functions that enable to construct them quickly. #### case 2: you know the shape of your tissue he function create_target_space_from_image creates a target space by using a user-generated image. The image has to be a black shape drawn onto a white background. You can do it in Fiji for instance. tissue_path = &#39;data/data_day2/tissue_example.png&#39; locations2 = novosparc.geometry.create_target_space_from_image(tissue_path) print(locations2[:3,]) This creates a very large number of locations, so it is better to subsample them. print (&#39;dimension of original tissue space:&#39;, locations2.shape) locations2 = locations2[np.random.choice(locations2.shape[0], 2000), :] print (&#39;dimension of downsampled tissue space:&#39;, locations2.shape[0]) plt.figure() plt.scatter(locations2[:, 0], locations2[:, 1],s=1) plt.show() plt.close() 3.2.2.1 case 3 : you assume that your tissue is a rectangle The function construct_target_grid can be used to construct a basic rectangular grid as target space. The only parameter is the total number of cellular locations on the target grid. locations3 = novosparc.geometry.construct_target_grid(500) plt.figure() plt.scatter(locations3[:, 0], locations3[:, 1], s=1) plt.show() plt.close() "],["predict-the-spatial-transcriptome.html", " 4 3. Predict the spatial transcriptome 4.1 Predict the spatial transcriptome (without landmark genes)", " 4 3. Predict the spatial transcriptome 4.1 Predict the spatial transcriptome (without landmark genes) Once you have defined the cellular locations, you can create a “tissue” object that will contain the predicted spatial transcriptome. # create a tissue object, the results will be saved in the directory &quot;outputs&quot; tissue = novosparc.cm.Tissue(dataset=dataset, locations=locations, output_folder=&#39;outputs&#39;) Principle of novosparc reconstruction (if no landmarks genes are provided) : Construct a k-nearest neighbors (knn) graph for the physical space (cellular location) : calculate the (euclidian) distance matrix between the locations, then for each location only keep the k-nearest neighbours (the value k is set by num_neighbors_s). for the expression space (single cells) : calculate the distance (correlation) matrix between the each cells, then for each location only keep the k-nearest neighbours (the value k is set by num_neighbors_t) Computes the shortest path lengths for each pair of cells, this step results in graph-based distance matrices for cells and for locations. Match the N single cells to the M positions using these graphs: the algorithm try to minimize the discrepancy between the pair-wise graph-based distances in expression space and in physical space tissue.setup_reconstruction(num_neighbors_s = 5, num_neighbors_t = 5) # compute the knn graphs Now we can reconstruct our tissue. The alpha_linear parameter controls the contribution of the two branches in novoSpaRc: alpha_linear=0 means that no prior information is available tissue.reconstruct(alpha_linear=0, epsilon=5e-3) We store the spatial gene expression matrix (sDGE) for the highly variable genes across all locations in a new variable sdge_hvg = tissue.sdge Plot the predicted patterns plt.figure(figsize=(12,4)) plt.subplot(231) plt.scatter(locations[:, 0], locations[:, 1], c=sdge_hvg[np.argwhere(hvg == &#39;ftz&#39;)[0], :].flatten(), s=1) plt.axis(&#39;off&#39;) plt.subplot(232) plt.scatter(locations[:, 0], locations[:, 1], c=sdge_hvg[np.argwhere(hvg == &#39;twi&#39;)[0], :].flatten(), s=1) plt.axis(&#39;off&#39;) plt.subplot(233) plt.scatter(locations[:, 0], locations[:, 1], c=sdge_hvg[np.argwhere(hvg == &#39;zen&#39;)[0], :].flatten(), s=1) plt.axis(&#39;off&#39;) plt.subplot(234) plt.scatter(locations[:, 0], locations[:, 1], c=sdge_hvg[np.argwhere(hvg == &#39;ImpE2&#39;)[0], :].flatten(), s=1) plt.axis(&#39;off&#39;) plt.subplot(235) plt.scatter(locations[:, 0], locations[:, 1], c=sdge_hvg[np.argwhere(hvg == &#39;sim&#39;)[0], :].flatten(), s=1) plt.axis(&#39;off&#39;) plt.subplot(236) plt.scatter(locations[:, 0], locations[:, 1], c=sdge_hvg[np.argwhere(hvg == &#39;pyr&#39;)[0], :].flatten(), s=1) plt.axis(&#39;off&#39;) plt.show() plt.close() This reconstruction has been realised without priori information. We can greatly improve the prediction by adding landmark genes ## Predict the spatial transcriptome (with landmark genes) ### Import landmark genes insitu_genes = np.genfromtxt(datafile_atlas, usecols=range(84), dtype=&#39;str&#39;, max_rows=1) atlas_matrix = np.loadtxt(datafile_atlas, usecols=range(84), skiprows=1) # je prends seulement 3 genes # faudrait filter les colonnes de atlas_matrix pour ietre sure que les noms # de genes sont les memes que ceux dans single cells insitu_genes = insitu_genes[2:5] atlas_matrix = atlas_matrix[:,2:5] On cherche les colonnes dans les données single cells qui matchent gene_names = tissue_with_markers.gene_names markers_in_sc = np.array([], dtype=&#39;int&#39;) # indice marker dans table sc for marker in insitu_genes: marker_index = np.where(gene_names == marker)[0] if len(marker_index) &gt; 0: markers_in_sc = np.append(markers_in_sc, marker_index[0]) print(markers_in_sc.shape ) print(gene_names[markers_in_sc]) We are going to create a new tissue object and specify the markers to use # contrairement au tutoriel, je ne pense pas qu&#39;on doivent specifier la # amtrice de marker quand on crée l&#39;ebjet tissue tissue_with_markers = novosparc.cm.Tissue(dataset=dataset, locations=locations) tissue_with_markers.setup_reconstruction(markers_to_use=markers_in_sc, insitu_matrix=atlas_matrix,num_neighbors_s = 5, num_neighbors_t = 5) # compute the knn graphs alpha_linear = 0.5 alpha_linear = 0.5 tissue_with_markers.reconstruct(alpha_linear=0.5, epsilon=5e-3) sdge_hvg2 = tissue_with_markers.sdge "],["session-info.html", " 5 Session info", " 5 Session info ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-conda-linux-gnu (64-bit) ## Running under: Ubuntu 16.04.4 LTS ## ## Matrix products: default ## BLAS/LAPACK: /import/kg_csbws03/lehmann/miniconda3/envs/cellid/lib/libopenblasp-r0.3.12.so ## ## locale: ## [1] LC_CTYPE=fr_FR.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=fr_FR.UTF-8 LC_COLLATE=fr_FR.UTF-8 ## [5] LC_MONETARY=fr_FR.UTF-8 LC_MESSAGES=fr_FR.UTF-8 ## [7] LC_PAPER=fr_FR.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=fr_FR.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] Seurat_3.2.3 reticulate_1.18 ## ## loaded via a namespace (and not attached): ## [1] nlme_3.1-151 matrixStats_0.57.0 RcppAnnoy_0.0.18 ## [4] RColorBrewer_1.1-2 httr_1.4.2 sctransform_0.3.2 ## [7] tools_4.0.3 R6_2.5.0 irlba_2.3.3 ## [10] rpart_4.1-15 KernSmooth_2.23-18 uwot_0.1.10 ## [13] mgcv_1.8-33 DBI_1.1.1 lazyeval_0.2.2 ## [16] colorspace_2.0-0 gridExtra_2.3 tidyselect_1.1.0 ## [19] compiler_4.0.3 plotly_4.9.3 labeling_0.4.2 ## [22] bookdown_0.21 scales_1.1.1 spatstat.data_1.7-0 ## [25] lmtest_0.9-38 ggridges_0.5.3 pbapply_1.4-3 ## [28] goftest_1.2-2 spatstat_1.64-1 stringr_1.4.0 ## [31] digest_0.6.27 spatstat.utils_1.20-2 rmarkdown_2.6 ## [34] pkgconfig_2.0.3 htmltools_0.5.1 parallelly_1.23.0 ## [37] fastmap_1.0.1 htmlwidgets_1.5.3 rlang_0.4.10 ## [40] rstudioapi_0.13 shiny_1.5.0 farver_2.0.3 ## [43] generics_0.1.0 zoo_1.8-8 jsonlite_1.7.2 ## [46] ica_1.0-2 dplyr_1.0.3 magrittr_2.0.1 ## [49] patchwork_1.1.1 Matrix_1.3-2 Rcpp_1.0.6 ## [52] munsell_0.5.0 abind_1.4-5 lifecycle_0.2.0 ## [55] stringi_1.5.3 yaml_2.2.1 MASS_7.3-53 ## [58] Rtsne_0.15 plyr_1.8.6 grid_4.0.3 ## [61] parallel_4.0.3 listenv_0.8.0 promises_1.1.1 ## [64] ggrepel_0.9.1 crayon_1.3.4 deldir_0.2-9 ## [67] miniUI_0.1.1.1 lattice_0.20-41 cowplot_1.1.1 ## [70] splines_4.0.3 tensor_1.5 knitr_1.30 ## [73] pillar_1.4.7 igraph_1.2.6 reshape2_1.4.4 ## [76] future.apply_1.7.0 codetools_0.2-18 leiden_0.3.6 ## [79] glue_1.4.2 evaluate_0.14 data.table_1.13.6 ## [82] vctrs_0.3.6 png_0.1-7 httpuv_1.5.5 ## [85] polyclip_1.10-0 gtable_0.3.0 RANN_2.6.1 ## [88] purrr_0.3.4 tidyr_1.1.2 scattermore_0.7 ## [91] future_1.21.0 assertthat_0.2.1 ggplot2_3.3.3 ## [94] xfun_0.20 rsvd_1.0.3 mime_0.9 ## [97] xtable_1.8-4 RSpectra_0.16-0 later_1.1.0.1 ## [100] survival_3.2-7 viridisLite_0.3.0 tibble_3.0.5 ## [103] cluster_2.1.0 globals_0.14.0 fitdistrplus_1.1-3 ## [106] ellipsis_0.3.1 ROCR_1.0-11 "]]
